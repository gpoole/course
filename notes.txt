List is a Functor (can take a function that maps a to b)
List is Applicative (can take an Applicative function that maps Applicative a to Applicative b)

Applicative functions support applying a function to multiple functors

In this example:
(+) <$> Just 2
- We are taking the function +, partially applying it by fmapping it onto Just 2,
but the result of the fmap will be Just (+2), which would require extra logic to apply
again to add 3 for example. Applicative functors allow us to reapply this
partially applied function:
(+) <$> Just 2 <*> Just 3

Think of it as an fmap that results in a Applicative partially applied function.
The example for list is confusing because the items in the list are already partially
applied functions. A clearer example might be fmapping a partial function onto a list
then applying the results of that to another list

(+) <$> (1 :. 2 :. 3 :. Nil)

A monoid is:
* A set (datatype) (numbers)
* with a binary associative operator (an operation) (+)
* With an identity for the operation (+0) -- support empty sets
monoid == foldable?

liftn = fmap with n arguments
(a -> b -> * -> n) -> f a -> f b -> f * -> fn
E.g. I want to call a function that takes a bunch of Option arguments without having
to handle the effect

lift0 = pure = a -> f a
lift1 = fmap = (a -> b) -> f a -> f b
lift2 = apply = f (a -> b) -> f a -> f b = same as fmap but with a pure map
lift3 = f (a -> b -> c) -> f a -> f b -> fc = same as apply but for three argument functions

e.g. you could do
foldr op id (instance of the set)

Semigroup is like a partial monoid:
* A set
* A binary associative operation

Example of application of a monoid
-- Glue a list of functions together and return the result
func = foldRight (.) id

const = a -> b -> a
const a b = a
Basically ignore b

<$> (a -> b) -> f a -> f b == fmap
<*> f (a -> b) -> f a -> f b == apply
<=<<> (a -> f b) -> f a -> f b == bind
<<<=> (f a -> b) -> f a -> f b == cobind

What is the reader pattern?

list keeps applying the parser till it doesn't work anymore

applicative is for taking the result of a map and applying it to a next set of things

pure produces an applicative value that does nothing to the other argument in an apply

Parser contains a single function that maps Input (Char) to something
pure creates a parser that returns a Result with whatever the passed value is
calling map on Parser creates a new parser that will call the function on the result
calling apply on Parser takes a Parser on the left with a function partially applied to the
result and passes the next parser's result as the second parameter
calling bind on Parser creates a new parser that will run after the previous one and
receive the result

map = modifying
apply = combining
bind = sequencing

sequence = List f a -> f List a
